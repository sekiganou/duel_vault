generator client {
  provider      = "prisma-client-js"
  output        = "../generated/prisma"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Deck {
  id           Int       @id @default(autoincrement())
  avatar       String?
  name         String
  archetype    Archetype @relation(fields: [archetypeId], references: [id])
  archetypeId  Int
  format       Format    @relation(fields: [formatId], references: [id])
  formatId     Int
  description  String? 
  active       Boolean   @default(true)
  wins         Int       @default(0) 
  losses       Int       @default(0) 
  ties         Int       @default(0) 
  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt

  matchesA     Match[]   @relation("DeckA")
  matchesB     Match[]   @relation("DeckB")
  winsAs       Match[]   @relation("Winner")

  tournamentStats TournamentDeckStats[]

  @@map("decks")
}

enum TournamentStatus {
  UPCOMING
  ONGOING
  COMPLETED
}

model Tournament {
  id         Int       @id @default(autoincrement())
  name       String
  format     Format    @relation(fields: [formatId], references: [id])
  formatId   Int
  startDate  DateTime
  endDate    DateTime?
  notes      String?
  link       String?
  updatedAt  DateTime? @updatedAt
  createdAt  DateTime  @default(now())
  status     TournamentStatus @default(UPCOMING)

  stages     TournamentStages[]
  matches    Match[]
  deckStats  TournamentDeckStats[]

  @@map("tournaments")
}

model Match {
  id            Int       @id @default(autoincrement())
  tournament    Tournament? @relation(fields: [tournamentId], references: [id],  onDelete: Cascade)
  tournamentId  Int?

  deckA         Deck      @relation("DeckA", fields: [deckAId], references: [id])
  deckAId       Int

  deckB         Deck      @relation("DeckB", fields: [deckBId], references: [id])
  deckBId       Int

  winner        Deck?     @relation("Winner", fields: [winnerId], references: [id])
  winnerId      Int?

  deckAScore    Int
  deckBScore    Int
  notes         String?
  date          DateTime
  updatedAt     DateTime? @updatedAt
  createdAt     DateTime  @default(now())

  @@map("matches")
}

model Archetype {
  id    Int    @id @default(autoincrement())
  name  String @unique

  decks Deck[]

  @@map("archetypes")
}

model Format {
  id    Int    @id @default(autoincrement())
  name  String @unique

  decks       Deck[]
  tournaments Tournament[]

  @@map("formats")
}

model TournamentDeckStats {
  id           Int        @id @default(autoincrement())
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int

  deck         Deck       @relation(fields: [deckId], references: [id])
  deckId       Int

  position     Int?

  wins         Int
  losses       Int
  ties         Int

  @@unique([tournamentId, deckId])
  @@map("tournament_deck_stats")
}

model TournamentStages {
  id          Int      @id @default(autoincrement())

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int

  name        String
  order       Int

  fileKey    String    // S3 key for the stage file (e.g., JSON or CSV)
  createdAt  DateTime @default(now())
  updatedAt  DateTime? @updatedAt

  @@map("tournament_stages")
}